<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自定義地點修復驗證測試</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        .test-container {
            border: 2px solid #007bff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .success { border-color: #28a745; background-color: #d4edda; }
        .error { border-color: #dc3545; background-color: #f8d7da; }
        .w-full { width: 100%; margin: 10px 0; }
        select, input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
        }
        .result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>自定義地點修復驗證測試</h1>
    <p>此測試驗證修復後的自定義地點填寫邏輯是否正常工作</p>

    <div id="test1" class="test-container">
        <h3>測試 1: 基本自定義地點填寫</h3>
        <div class="w-full">
            <select id="select1">
                <option value="">請選擇地點</option>
                <option value="弘道基地">弘道基地</option>
                <option value="吉林基地">吉林基地</option>
                <option value="在家中">在家中</option>
                <option value="其他地點">其他地點</option>
            </select>
        </div>
        <button onclick="runTest1()">測試填寫「實習公司」</button>
        <div id="result1" class="result"></div>
    </div>

    <div id="test2" class="test-container">
        <h3>測試 2: 已預設為其他地點的情況</h3>
        <div class="w-full">
            <select id="select2">
                <option value="">請選擇地點</option>
                <option value="弘道基地">弘道基地</option>
                <option value="吉林基地">吉林基地</option>
                <option value="在家中">在家中</option>
                <option value="其他地點" selected>其他地點</option>
            </select>
            <input type="text" placeholder="請填寫地點名稱" style="display:block;">
        </div>
        <button onclick="runTest2()">測試填寫「圖書館」</button>
        <div id="result2" class="result"></div>
    </div>

    <div id="test3" class="test-container">
        <h3>測試 3: React 風格的受控輸入框</h3>
        <div class="w-full">
            <select id="select3">
                <option value="">請選擇地點</option>
                <option value="弘道基地">弘道基地</option>
                <option value="吉林基地">吉林基地</option>
                <option value="在家中">在家中</option>
                <option value="其他地點">其他地點</option>
            </select>
        </div>
        <button onclick="runTest3()">測試React受控輸入「咖啡廳」</button>
        <div id="result3" class="result"></div>
    </div>

    <button onclick="clearResults()">清除所有結果</button>

    <script>
        // 比原本「寬高>0」更穩定：看 computedStyle 與禁用態
        function isInputReady(input) {
          if (!input) return false;
          const cs = getComputedStyle(input);
          const visible = cs.display !== 'none' && cs.visibility !== 'hidden' && cs.opacity !== '0';
          return visible && !input.disabled && !input.readOnly;
        }

        // 用原生 setter 寫值，解決 React/受控輸入不同步
        function setNativeInputValue(input, value) {
          // 方法1：使用原生 HTMLInputElement.prototype.value setter
          const nativeSetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value').set;

          if (nativeSetter) {
            nativeSetter.call(input, value);
            console.log('使用原生 setter 設置值:', value);
          } else {
            // 備用方法：直接設置
            input.value = value;
            console.log('使用直接設置值:', value);
          }

          // 模擬用戶輸入：先觸發 input 事件，再觸發 change 事件
          const inputEvent = new Event('input', { bubbles: true, cancelable: true });
          Object.defineProperty(inputEvent, 'target', {
            value: input,
            enumerable: true
          });
          input.dispatchEvent(inputEvent);

          const changeEvent = new Event('change', { bubbles: true, cancelable: true });
          Object.defineProperty(changeEvent, 'target', {
            value: input,
            enumerable: true
          });
          input.dispatchEvent(changeEvent);

          console.log('事件已觸發，當前值:', input.value);
        }

        // 等待/取得該 slot 的自訂輸入框：優先用 MutationObserver，退而求其次輪詢
        function getOrWaitCustomInput(container, select, maxWaitMs = 3000) {
          return new Promise((resolve) => {
            // 先查一次
            const q = () => container?.querySelector('input[type="text"], input[placeholder*="地點"], input[placeholder*="名稱"], input.input');
            let found = q();
            if (found) return resolve(found);

            // 確保 select 已是「其他地點」
            if (select && select.value !== '其他地點') {
              select.value = '其他地點';
              select.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
              select.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }

            // 用 MutationObserver 等待輸入框出現
            const obs = new MutationObserver(() => {
              const el = q();
              if (el) {
                obs.disconnect();
                resolve(el);
              }
            });
            if (container) {
              obs.observe(container, { childList: true, subtree: true });
            }

            // 兜底 timeout
            setTimeout(() => {
              obs.disconnect();
              resolve(q() || null);
            }, maxWaitMs);
          });
        }

        async function fillCustomLocation(container, customName, slotIndex) {
          console.log(`測試填寫自訂地點: 時段 ${slotIndex + 1}, 地點: "${customName}"`);
          try {
            const select = container?.querySelector('select');

            // 確保「其他地點」已選
            if (select && select.value !== '其他地點') {
              select.value = '其他地點';
              select.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
              select.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }

            // 取得或等待 input
            const input = await getOrWaitCustomInput(container, select, 3000);

            if (!input) {
              console.error(`時段 ${slotIndex + 1}: 找不到輸入框`);
              return { success: false, reason: 'no-input', customLocationValue: null };
            }

            // 有些站點會短暫設為 readonly/disabled，這裡強制解除一次
            input.disabled = false;
            input.readOnly = false;

            // 滾到可見（避免某些框架對不可見元素忽略事件）
            input.scrollIntoView?.({ block: 'center', inline: 'nearest' });

            // 就算 isInputReady 回 false，也先試著填 — 很多時候其實能寫
            input.focus();
            setNativeInputValue(input, customName);
            input.blur();

            // 驗證
            const ok = input.value === customName;
            console.log(`時段 ${slotIndex + 1}: 自訂地點填寫 ${ok ? '✅' : '❌'} "${customName}" -> "${input.value}"`);
            return { success: ok, reason: ok ? 'filled' : 'value-mismatch', customLocationValue: input.value };
          } catch (err) {
            console.error(`時段 ${slotIndex + 1}: 填寫時發生錯誤:`, err);
            return { success: false, reason: 'fill-error', customLocationValue: null, error: err?.message };
          }
        }

        function logResult(testId, message, data) {
            const resultDiv = document.getElementById(`result${testId}`);
            const timestamp = new Date().toLocaleTimeString();
            const success = data?.success;

            resultDiv.className = `result ${success ? 'success' : 'error'}`;
            resultDiv.textContent = `[${timestamp}] ${message}\n${JSON.stringify(data, null, 2)}`;

            const container = document.getElementById(`test${testId}`);
            container.className = `test-container ${success ? 'success' : 'error'}`;
        }

        // 模擬動態生成輸入框（當選擇其他地點時）
        function setupDynamicInput(selectId) {
            const select = document.getElementById(selectId);
            const container = select.closest('.w-full');

            select.addEventListener('change', function() {
                // 移除既有的輸入框
                const existingInput = container.querySelector('input[type="text"]');
                if (existingInput) {
                    existingInput.remove();
                }

                // 如果選擇「其他地點」，動態添加輸入框
                if (this.value === '其他地點') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = '請填寫地點名稱';
                    input.style.marginTop = '10px';
                    input.style.display = 'block';
                    container.appendChild(input);
                }
            });
        }

        // 模擬 React 受控輸入框行為
        function setupReactControlledInput(selectId) {
            const select = document.getElementById(selectId);
            const container = select.closest('.w-full');
            let reactState = '';

            select.addEventListener('change', function() {
                // 移除既有的輸入框
                const existingInput = container.querySelector('input[type="text"]');
                if (existingInput) {
                    existingInput.remove();
                }

                // 如果選擇「其他地點」，動態添加受控輸入框
                if (this.value === '其他地點') {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = '請填寫地點名稱';
                    input.style.marginTop = '10px';
                    input.style.display = 'block';
                    container.appendChild(input);

                    // 儲存原生 setter 的引用
                    const nativeSetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value').set;
                    const nativeGetter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value').get;

                    // 模擬 React 受控行為：攔截 value 的 get/set
                    let isNativeCall = false;

                    Object.defineProperty(input, 'value', {
                        get: () => {
                            if (isNativeCall) {
                                return nativeGetter.call(input);
                            }
                            return reactState;
                        },
                        set: (newValue) => {
                            // 檢查調用堆疊以判斷是否為原生 setter 調用
                            const error = new Error();
                            const stack = error.stack;

                            // 如果是我們的 setNativeInputValue 函數調用，則允許更新
                            if (stack && stack.includes('setNativeInputValue')) {
                                isNativeCall = true;
                                nativeSetter.call(input, newValue);
                                isNativeCall = false;
                                reactState = newValue;
                                input.setAttribute('value', reactState);
                                console.log('React state updated via native setter:', reactState);
                            } else {
                                console.log('Direct value set (React would ignore this):', newValue);
                            }
                        }
                    });

                    // 監聽 input 事件來更新 React state
                    input.addEventListener('input', function(e) {
                        reactState = e.target.value;
                        input.setAttribute('value', reactState);
                        console.log('React state updated via input event:', reactState);
                    });

                    // 監聽 change 事件
                    input.addEventListener('change', function(e) {
                        reactState = e.target.value;
                        input.setAttribute('value', reactState);
                        console.log('React state updated via change event:', reactState);
                    });
                }
            });
        }

        async function runTest1() {
            logResult(1, '開始測試基本自定義地點填寫...', { status: 'starting' });
            const container = document.querySelector('#test1 .w-full');

            try {
                const result = await fillCustomLocation(container, '實習公司', 0);
                logResult(1, '測試完成', result);
            } catch (error) {
                logResult(1, '測試發生錯誤', { success: false, error: error.message });
            }
        }

        async function runTest2() {
            logResult(2, '開始測試已預設為其他地點的情況...', { status: 'starting' });
            const container = document.querySelector('#test2 .w-full');

            try {
                const result = await fillCustomLocation(container, '圖書館', 0);
                logResult(2, '測試完成', result);
            } catch (error) {
                logResult(2, '測試發生錯誤', { success: false, error: error.message });
            }
        }

        async function runTest3() {
            logResult(3, '開始測試React受控輸入框...', { status: 'starting' });
            const container = document.querySelector('#test3 .w-full');

            try {
                const result = await fillCustomLocation(container, '咖啡廳', 0);
                logResult(3, '測試完成', result);
            } catch (error) {
                logResult(3, '測試發生錯誤', { success: false, error: error.message });
            }
        }

        function clearResults() {
            for (let i = 1; i <= 3; i++) {
                document.getElementById(`result${i}`).textContent = '';
                document.getElementById(`test${i}`).className = 'test-container';
            }
        }

        // 初始化測試環境
        document.addEventListener('DOMContentLoaded', function() {
            setupDynamicInput('select1');
            setupReactControlledInput('select3');
            console.log('自定義地點修復驗證測試已初始化');
        });
    </script>
</body>
</html>